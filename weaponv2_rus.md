
# Техническое задание: Интеграция системы детерминированной баллистики  в Bevy

## 1. Общие сведения

Цель проекта — заменить упрощенную систему снарядов в `weapons.rs` на высокоточную физическую симуляцию. Система должна учитывать внешние факторы (ветер, плотность воздуха), физические свойства пули (масса, сопротивление) и сложное взаимодействие с поверхностями (рикошеты, пробитие).

## 2. Архитектурные требования

Для обеспечения производительности, сопоставимой с *Unity Job System + Burst*, реализация в Bevy должна:

* Использовать **Parallel System** для обработки снарядов.
* Максимально задействовать **SIMD** через библиотеку `glam` (встроенную в Bevy).
* Реализовать **Object Pooling** (пул объектов) для визуальных эффектов попаданий и трассировщиков.

---

## 3. Технические спецификации

### 3.1. Глобальная среда (Environment Settings)

Создать ресурс `BallisticsEnvironment`, хранящий:

* `gravity`: Vec3 (ускорение свободного падения).
* `air_density`: f32 (плотность воздуха, влияющая на сопротивление).
* `wind`: Vec3 (вектор силы ветра).

### 3.2. Компонент снаряда (Bullet Settings)

Расширить структуру `Projectile`, добавив физические параметры:

* `mass`: f32 (масса пули в кг).
* `drag_coefficient`: f32 (коэффициент лобового сопротивления).
* `reference_area`: f32 (площадь поперечного сечения).
* `penetration_power`: f32 (начальная проникающая способность).
* `velocity`: Vec3 (текущий вектор скорости).

### 3.3. Математическая модель (Velocity Calculation)

Заменить линейное перемещение на метод **Рунге-Кутты 4-го порядка (RK4)** для расчета траектории.

* **Уравнение:** учитывать силу тяжести и силу сопротивления воздуха .
Псевдокод расчета (для одного шага симуляции)
Этот блок описывает логику, которую вы внедрите в системный цикл Bevy для обновления вектора скорости пули.

```
# 1. Получение входных данных из ресурсов и компонентов
gravity = Vec3(0, -9.81, 0)         # Из BallisticsEnvironment
air_density = 1.225                 # Плотность воздуха (кг/m^3)
wind_velocity = Vec3(2.0, 0, 0)     # Вектор ветра

# Параметры пули
velocity = projectile.velocity      # Текущая скорость
mass = projectile.mass              # Масса (кг)
drag_coeff = projectile.drag_coeff  # Cd (напр. 0.3)
area = projectile.reference_area    # Площадь сечения (m^2)

# 2. Расчет относительной скорости (учет ветра)
# Ветер "толкает" пулю, поэтому мы считаем скорость пули относительно воздуха
relative_velocity = velocity - wind_velocity
speed = relative_velocity.length()
direction = relative_velocity.normalize()

# 3. Расчет силы сопротивления (Drag Force)
# Формула: 0.5 * density * speed^2 * Cd * Area
drag_magnitude = 0.5 * air_density * (speed * speed) * drag_coeff * area
drag_force_vector = direction * -drag_magnitude

# 4. Расчет результирующего ускорения (Второй закон Ньютона)
# a = g + (F_drag / m)
acceleration = gravity + (drag_force_vector / mass)

# 5. Интеграция (Метод Эйлера или RK4)
# Для простого Эйлера:
projectile.velocity += acceleration * delta_time
projectile.position += projectile.velocity * delta_time
```

* **Детекция столкновений:** выполнять `spatial_query.cast_ray` строго между позицией в кадре  и расчетной позицией в кадре  для исключения "пролетов" сквозь объекты.

---

## 4. Система взаимодействия с поверхностями (Surface Interactions)

Необходимо внедрить систему меток (Tags) или метаданных для игровых объектов:

| Параметр | Описание |
| --- | --- |
| **Ricochet Ability** | Угол, при котором пуля отражается, а не поглощается. |
| **Penetration Loss** | Коэффициент потери скорости/энергии при пробитии материала. |
| **Hit Effects** | Тип эффекта (искра, пыль, кровь) при попадании. |

### Алгоритм пробития:

1. При попадании проверяется `penetration_power` пули против толщины и плотности препятствия.
2. Если пробитие успешно: пуля продолжает полет из точки выхода с уменьшенной скоростью.
3. Если неуспешно: пуля деспавнится, создается эффект попадания.

---

## 5. Дополнительный функционал

### 5.1. Пристрелка (Weapon Zeroing)

Добавить метод в `Weapon`:

* Автоматический расчет угла наклона ствола (`Pitch`) для компенсации падения пули на заданной дистанции (например, 100м, 300м, 500м).

### 5.2. Разделение визуализации и симуляции

* **Backend:** Математический расчет координат пули.
* **Frontend:** Отдельный компонент `BulletTracer` (визуальная модель/частицы), который интерполирует свою позицию вслед за данными симуляции. Это позволит кастомизировать визуал, не ломая физику.

---

## 6. План реализации в `weapons.rs`

1. **Data Update:** Добавить `mass`, `drag`, `area` в структуру `Weapon` и `Projectile`.
2. **Resources:** Создать `BallisticsConfig` как `Resource` в Bevy.
3. **Core System:** Переписать `update_projectiles`, внедрив интеграцию RK4.
4. **Collision Logic:** Внутри `update_projectiles` добавить цикл обработки пробития: если луч нашел коллизию, запустить расчет остаточной энергии.
5. **Pooling:** Реализовать систему повторного использования сущностей (Entity) для искр и декалей.

Конечно. Для реализации системы разброса (Spread), вдохновленной *Bullet Dynamics*, мы отойдем от простого случайного угла и внедрим **динамическую модель**, которая зависит от состояния игрока, типа движения и накопленной "отдачи".

Ниже представлено дополнение к техническому заданию, сфокусированное на баллистическом разбросе.

---

## Дополнение к ТЗ: Система динамического разброса и точности

### 1. Модель конуса точности

Разброс должен рассчитываться не как статичное число, а как расширяющийся конус, основанный на нескольких множителях.

**Параметры компонента `Weapon`:**

* **Base Spread:** Минимальный угол разброса (в радианах) в идеальных условиях.
* **Max Spread:** Потолок расширения конуса при непрерывной стрельбе.
* **Bloom per Shot:** Значение, на которое увеличивается разброс после каждого выстрела.
* **Recovery Rate:** Скорость, с которой разброс возвращается к базовому значению в секунду.

### 2. Множители состояния (Modifiers)

Точность должна динамически меняться в зависимости от действий `WeaponManager` или игрока:

* **Movement Multiplier:** Увеличение разброса при движении (считывается из `Velocity` игрока).
* **Airborne Penalty:** Значительное падение точности, если игрок не касается земли.
* **Stance Multiplier:** Коэффициенты для положений «стоя», «сидя» и «лежа».
* **Aiming (ADS) Multiplier:** Уменьшение базового разброса при прицеливании (уже заложено в вашем коде как `aim_spread_mult`, но требует интеграции в общую формулу).

---

### 3. Алгоритм расчета (Расширение `fire_weapon`)

Вместо текущего упрощенного метода, расчет вектора выстрела будет выглядеть так:

1. **Вычисление текущего Bloom:** 
Для вычисления текущего разброса (Bloom) мы будем использовать модель накопления «энергии» или «тепла». Чем больше вы стреляете или двигаетесь, тем сильнее расширяется конус точности.

Ниже представлен псевдокод логики, которая объединяет базовую точность, штрафы за движение и накопленный Bloom.

Псевдокод: Расчет динамического разброса

```
# 1. Параметры оружия (из компонента Accuracy)
base_spread = weapon.base_spread        # Минимальный разброс (градусы/радианы)
max_bloom = weapon.max_bloom            # Максимальный дополнительный разброс
recovery_rate = weapon.recovery_rate    # Скорость остывания (единиц в сек)

# 2. Состояние игрока (из компонентов Transform/Velocity/Input)
is_aiming = input.aim_pressed           # Прицеливается ли игрок (ADS)
is_moving = player_velocity.length() > 0.1
is_airborne = !player.is_grounded

# 3. Обновление Bloom (остывание)
# Выполняется каждый кадр (Update)
weapon.current_bloom -= recovery_rate * delta_time
weapon.current_bloom = max(0.0, weapon.current_bloom) # Не ниже нуля

# 4. Вычисление финального множителя точности
# Начинаем с базового разброса + накопленный "нагрев" от выстрелов
total_spread = base_spread + weapon.current_bloom

# Штраф за движение
if is_moving:
    total_spread += weapon.movement_penalty * (player_velocity.length() / max_speed)

# Штраф за прыжок/полет
if is_airborne:
    total_spread *= weapon.airborne_multiplier

# Бонус за прицеливание (ADS)
if is_aiming:
    total_spread *= weapon.ads_modifier # Например, 0.2 (уменьшение на 80%)

# 5. Применение при выстреле
# При каждом вызове fire_weapon():
weapon.current_bloom = min(max_bloom, weapon.current_bloom + weapon.bloom_per_shot)
```


2. **Генерация точки внутри круга:**
Использование распределения Гаусса (вместо равномерного `random`), чтобы пули чаще летели ближе к центру, а не распределялись по краям круга равномерно.
3. **Применение трансформации:**
Поворот базового вектора `Forward` на полученные углы отклонения.

### 4. Интеграция с Recoil (Отдача)

Разброс (Spread) — это случайное отклонение внутри конуса. Отдача (Recoil) — это физическое смещение самого ствола (камеры).

* **Visual Kick:** Смещение `Transform` оружия вверх и назад.
* **Camera Pitch/Yaw:** Добавление импульса в систему управления камерой.

---

### Пример структуры данных для Rust:

```rust
#[derive(Component, Reflect)]
pub struct Accuracy {
    pub current_bloom: f32,
    pub base_spread: f32,
    pub max_spread: f32,
    pub bloom_per_shot: f32,
    pub recovery_rate: f32,
    // Множители
    pub movement_penalty: f32,
    pub ads_modifier: f32, // Напр. 0.2
}

```

### План внедрения:

1. **Update System:** Создать систему `calculate_dynamic_spread`, которая каждую итерацию `Update` уменьшает `current_bloom` и проверяет скорость игрока.
2. **Firing System:** В функции `fire_weapon` прибавлять `bloom_per_shot` к текущему состоянию.
3. **Visuals:** (Опционально) Добавить интерфейс (UI) в виде перекрестия, которое расширяется и сужается в зависимости от `current_bloom`.
